d95818aee3134eae2b2a1167732fa0aa
'use strict';

var _interopRequireDefault2 = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault2(require("@babel/runtime/regenerator"));

var _wrapNativeSuper2 = _interopRequireDefault2(require("@babel/runtime/helpers/wrapNativeSuper"));

var _slicedToArray2 = _interopRequireDefault2(require("@babel/runtime/helpers/slicedToArray"));

var _extends2 = _interopRequireDefault2(require("@babel/runtime/helpers/extends"));

var _classCallCheck2 = _interopRequireDefault2(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault2(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault2(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault2(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault2(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault2(require("@babel/runtime/helpers/getPrototypeOf"));

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

Object.defineProperty(exports, '__esModule', {
  value: true
});
Object.defineProperty(exports, 'CallbackTestRunner', {
  enumerable: true,
  get: function get() {
    return _types.CallbackTestRunner;
  }
});
Object.defineProperty(exports, 'EmittingTestRunner', {
  enumerable: true,
  get: function get() {
    return _types.EmittingTestRunner;
  }
});
exports.default = void 0;

function _chalk() {
  var data = _interopRequireDefault(require('chalk'));

  _chalk = function _chalk() {
    return data;
  };

  return data;
}

function _emittery() {
  var data = _interopRequireDefault(require('emittery'));

  _emittery = function _emittery() {
    return data;
  };

  return data;
}

function _throat() {
  var data = _interopRequireDefault(require('throat'));

  _throat = function _throat() {
    return data;
  };

  return data;
}

function _jestUtil() {
  var data = require('jest-util');

  _jestUtil = function _jestUtil() {
    return data;
  };

  return data;
}

function _jestWorker() {
  var data = require('jest-worker');

  _jestWorker = function _jestWorker() {
    return data;
  };

  return data;
}

var _runTest = _interopRequireDefault(require('./runTest'));

var _types = require('./types');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classPrivateMethodInitSpec(obj, privateSet) {
  _checkPrivateRedeclaration(obj, privateSet);

  privateSet.add(obj);
}

function _classPrivateFieldInitSpec(obj, privateMap, value) {
  _checkPrivateRedeclaration(obj, privateMap);

  privateMap.set(obj, value);
}

function _checkPrivateRedeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError('Cannot initialize the same private elements twice on an object');
  }
}

function _classPrivateFieldGet(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, 'get');

  return _classApplyDescriptorGet(receiver, descriptor);
}

function _classExtractFieldDescriptor(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError('attempted to ' + action + ' private field on non-instance');
  }

  return privateMap.get(receiver);
}

function _classApplyDescriptorGet(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }

  return descriptor.value;
}

function _classPrivateMethodGet(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError('attempted to get private field on non-instance');
  }

  return fn;
}

var _eventEmitter = new WeakMap();

var _createInBandTestRun = new WeakSet();

var _createParallelTestRun = new WeakSet();

var TestRunner = function (_types$EmittingTestRu) {
  (0, _inherits2.default)(TestRunner, _types$EmittingTestRu);

  var _super = _createSuper(TestRunner);

  function TestRunner() {
    var _this;

    (0, _classCallCheck2.default)(this, TestRunner);

    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
      _args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(_args));

    _classPrivateMethodInitSpec((0, _assertThisInitialized2.default)(_this), _createParallelTestRun);

    _classPrivateMethodInitSpec((0, _assertThisInitialized2.default)(_this), _createInBandTestRun);

    _classPrivateFieldInitSpec((0, _assertThisInitialized2.default)(_this), _eventEmitter, {
      writable: true,
      value: new (_emittery().default)()
    });

    return _this;
  }

  (0, _createClass2.default)(TestRunner, [{
    key: "runTests",
    value: function runTests(tests, watcher, options) {
      return _regenerator.default.async(function runTests$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return _regenerator.default.awrap(options.serial ? _classPrivateMethodGet(this, _createInBandTestRun, _createInBandTestRun2).call(this, tests, watcher) : _classPrivateMethodGet(this, _createParallelTestRun, _createParallelTestRun2).call(this, tests, watcher));

            case 2:
              return _context.abrupt("return", _context.sent);

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, null, this, null, Promise);
    }
  }, {
    key: "on",
    value: function on(eventName, listener) {
      return _classPrivateFieldGet(this, _eventEmitter).on(eventName, listener);
    }
  }]);
  return TestRunner;
}(_types.EmittingTestRunner);

exports.default = TestRunner;

function _createInBandTestRun2(tests, watcher) {
  var _this2 = this;

  var mutex;
  return _regenerator.default.async(function _createInBandTestRun2$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          process.env.JEST_WORKER_ID = '1';
          mutex = (0, _throat().default)(1);
          return _context3.abrupt("return", tests.reduce(function (promise, test) {
            return mutex(function () {
              return promise.then(function _callee() {
                var sendMessageToJest;
                return _regenerator.default.async(function _callee$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        if (!watcher.isInterrupted()) {
                          _context2.next = 2;
                          break;
                        }

                        throw new CancelRun();

                      case 2:
                        sendMessageToJest = function sendMessageToJest(eventName, args) {
                          return _classPrivateFieldGet(_this2, _eventEmitter).emit(eventName, (0, _jestUtil().deepCyclicCopy)(args, {
                            keepPrototype: false
                          }));
                        };

                        _context2.next = 5;
                        return _regenerator.default.awrap(_classPrivateFieldGet(_this2, _eventEmitter).emit('test-file-start', [test]));

                      case 5:
                        return _context2.abrupt("return", (0, _runTest.default)(test.path, _this2._globalConfig, test.context.config, test.context.resolver, _this2._context, sendMessageToJest));

                      case 6:
                      case "end":
                        return _context2.stop();
                    }
                  }
                }, null, null, null, Promise);
              }).then(function (result) {
                return _classPrivateFieldGet(_this2, _eventEmitter).emit('test-file-success', [test, result]);
              }, function (error) {
                return _classPrivateFieldGet(_this2, _eventEmitter).emit('test-file-failure', [test, error]);
              });
            });
          }, Promise.resolve()));

        case 3:
        case "end":
          return _context3.stop();
      }
    }
  }, null, null, null, Promise);
}

function _createParallelTestRun2(tests, watcher) {
  var _this3 = this;

  var resolvers, _iterator, _step, test, worker, mutex, runTestInWorker, onInterrupt, runAllTests, cleanup;

  return _regenerator.default.async(function _createParallelTestRun2$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          resolvers = new Map();

          for (_iterator = _createForOfIteratorHelperLoose(tests); !(_step = _iterator()).done;) {
            test = _step.value;

            if (!resolvers.has(test.context.config.id)) {
              resolvers.set(test.context.config.id, {
                config: test.context.config,
                serializableModuleMap: test.context.moduleMap.toJSON()
              });
            }
          }

          worker = new (_jestWorker().Worker)(require.resolve('./testWorker'), {
            exposedMethods: ['worker'],
            forkOptions: {
              serialization: 'json',
              stdio: 'pipe'
            },
            maxRetries: 3,
            numWorkers: this._globalConfig.maxWorkers,
            setupArgs: [{
              serializableResolvers: Array.from(resolvers.values())
            }]
          });
          if (worker.getStdout()) worker.getStdout().pipe(process.stdout);
          if (worker.getStderr()) worker.getStderr().pipe(process.stderr);
          mutex = (0, _throat().default)(this._globalConfig.maxWorkers);

          runTestInWorker = function runTestInWorker(test) {
            return mutex(function _callee2() {
              var promise;
              return _regenerator.default.async(function _callee2$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      if (!watcher.isInterrupted()) {
                        _context4.next = 2;
                        break;
                      }

                      return _context4.abrupt("return", Promise.reject());

                    case 2:
                      _context4.next = 4;
                      return _regenerator.default.awrap(_classPrivateFieldGet(_this3, _eventEmitter).emit('test-file-start', [test]));

                    case 4:
                      promise = worker.worker({
                        config: test.context.config,
                        context: (0, _extends2.default)({}, _this3._context, {
                          changedFiles: _this3._context.changedFiles && Array.from(_this3._context.changedFiles),
                          sourcesRelatedToTestsInChangedFiles: _this3._context.sourcesRelatedToTestsInChangedFiles && Array.from(_this3._context.sourcesRelatedToTestsInChangedFiles)
                        }),
                        globalConfig: _this3._globalConfig,
                        path: test.path
                      });

                      if (promise.UNSTABLE_onCustomMessage) {
                        promise.UNSTABLE_onCustomMessage(function (_ref) {
                          var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
                              event = _ref2[0],
                              payload = _ref2[1];

                          return _classPrivateFieldGet(_this3, _eventEmitter).emit(event, payload);
                        });
                      }

                      return _context4.abrupt("return", promise);

                    case 7:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, null, null, null, Promise);
            });
          };

          onInterrupt = new Promise(function (_, reject) {
            watcher.on('change', function (state) {
              if (state.interrupted) {
                reject(new CancelRun());
              }
            });
          });
          runAllTests = Promise.all(tests.map(function (test) {
            return runTestInWorker(test).then(function (result) {
              return _classPrivateFieldGet(_this3, _eventEmitter).emit('test-file-success', [test, result]);
            }, function (error) {
              return _classPrivateFieldGet(_this3, _eventEmitter).emit('test-file-failure', [test, error]);
            });
          }));

          cleanup = function _callee3() {
            var _await$worker$end, forceExited;

            return _regenerator.default.async(function _callee3$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    _context5.next = 2;
                    return _regenerator.default.awrap(worker.end());

                  case 2:
                    _await$worker$end = _context5.sent;
                    forceExited = _await$worker$end.forceExited;

                    if (forceExited) {
                      console.error(_chalk().default.yellow('A worker process has failed to exit gracefully and has been force exited. ' + 'This is likely caused by tests leaking due to improper teardown. ' + 'Try running with --detectOpenHandles to find leaks. ' + 'Active timers can also cause this, ensure that .unref() was called on them.'));
                    }

                  case 5:
                  case "end":
                    return _context5.stop();
                }
              }
            }, null, null, null, Promise);
          };

          return _context6.abrupt("return", Promise.race([runAllTests, onInterrupt]).then(cleanup, cleanup));

        case 11:
        case "end":
          return _context6.stop();
      }
    }
  }, null, this, null, Promise);
}

var CancelRun = function (_Error) {
  (0, _inherits2.default)(CancelRun, _Error);

  var _super2 = _createSuper(CancelRun);

  function CancelRun(message) {
    var _this4;

    (0, _classCallCheck2.default)(this, CancelRun);
    _this4 = _super2.call(this, message);
    _this4.name = 'CancelRun';
    return _this4;
  }

  return (0, _createClass2.default)(CancelRun);
}((0, _wrapNativeSuper2.default)(Error));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJfdHlwZXMiLCJDYWxsYmFja1Rlc3RSdW5uZXIiLCJFbWl0dGluZ1Rlc3RSdW5uZXIiLCJkZWZhdWx0IiwiX2NoYWxrIiwiZGF0YSIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX2VtaXR0ZXJ5IiwiX3Rocm9hdCIsIl9qZXN0VXRpbCIsIl9qZXN0V29ya2VyIiwiX3J1blRlc3QiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX2NsYXNzUHJpdmF0ZU1ldGhvZEluaXRTcGVjIiwicHJpdmF0ZVNldCIsIl9jaGVja1ByaXZhdGVSZWRlY2xhcmF0aW9uIiwiYWRkIiwiX2NsYXNzUHJpdmF0ZUZpZWxkSW5pdFNwZWMiLCJwcml2YXRlTWFwIiwic2V0IiwicHJpdmF0ZUNvbGxlY3Rpb24iLCJoYXMiLCJUeXBlRXJyb3IiLCJfY2xhc3NQcml2YXRlRmllbGRHZXQiLCJyZWNlaXZlciIsImRlc2NyaXB0b3IiLCJfY2xhc3NFeHRyYWN0RmllbGREZXNjcmlwdG9yIiwiX2NsYXNzQXBwbHlEZXNjcmlwdG9yR2V0IiwiYWN0aW9uIiwiY2FsbCIsIl9jbGFzc1ByaXZhdGVNZXRob2RHZXQiLCJmbiIsIl9ldmVudEVtaXR0ZXIiLCJXZWFrTWFwIiwiX2NyZWF0ZUluQmFuZFRlc3RSdW4iLCJXZWFrU2V0IiwiX2NyZWF0ZVBhcmFsbGVsVGVzdFJ1biIsIlRlc3RSdW5uZXIiLCJfYXJncyIsIndyaXRhYmxlIiwidGVzdHMiLCJ3YXRjaGVyIiwib3B0aW9ucyIsInNlcmlhbCIsIl9jcmVhdGVJbkJhbmRUZXN0UnVuMiIsIl9jcmVhdGVQYXJhbGxlbFRlc3RSdW4yIiwiZXZlbnROYW1lIiwibGlzdGVuZXIiLCJvbiIsInByb2Nlc3MiLCJlbnYiLCJKRVNUX1dPUktFUl9JRCIsIm11dGV4IiwicmVkdWNlIiwicHJvbWlzZSIsInRlc3QiLCJ0aGVuIiwiaXNJbnRlcnJ1cHRlZCIsIkNhbmNlbFJ1biIsInNlbmRNZXNzYWdlVG9KZXN0IiwiYXJncyIsImVtaXQiLCJkZWVwQ3ljbGljQ29weSIsImtlZXBQcm90b3R5cGUiLCJwYXRoIiwiX2dsb2JhbENvbmZpZyIsImNvbnRleHQiLCJjb25maWciLCJyZXNvbHZlciIsIl9jb250ZXh0IiwicmVzdWx0IiwiZXJyb3IiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlc29sdmVycyIsIk1hcCIsImlkIiwic2VyaWFsaXphYmxlTW9kdWxlTWFwIiwibW9kdWxlTWFwIiwidG9KU09OIiwid29ya2VyIiwiV29ya2VyIiwiZXhwb3NlZE1ldGhvZHMiLCJmb3JrT3B0aW9ucyIsInNlcmlhbGl6YXRpb24iLCJzdGRpbyIsIm1heFJldHJpZXMiLCJudW1Xb3JrZXJzIiwibWF4V29ya2VycyIsInNldHVwQXJncyIsInNlcmlhbGl6YWJsZVJlc29sdmVycyIsIkFycmF5IiwiZnJvbSIsInZhbHVlcyIsImdldFN0ZG91dCIsInBpcGUiLCJzdGRvdXQiLCJnZXRTdGRlcnIiLCJzdGRlcnIiLCJydW5UZXN0SW5Xb3JrZXIiLCJyZWplY3QiLCJjaGFuZ2VkRmlsZXMiLCJzb3VyY2VzUmVsYXRlZFRvVGVzdHNJbkNoYW5nZWRGaWxlcyIsImdsb2JhbENvbmZpZyIsIlVOU1RBQkxFX29uQ3VzdG9tTWVzc2FnZSIsImV2ZW50IiwicGF5bG9hZCIsIm9uSW50ZXJydXB0IiwiXyIsInN0YXRlIiwiaW50ZXJydXB0ZWQiLCJydW5BbGxUZXN0cyIsImFsbCIsIm1hcCIsImNsZWFudXAiLCJlbmQiLCJmb3JjZUV4aXRlZCIsImNvbnNvbGUiLCJ5ZWxsb3ciLCJyYWNlIiwibWVzc2FnZSIsIm5hbWUiLCJFcnJvciJdLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0NhbGxiYWNrVGVzdFJ1bm5lcicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF90eXBlcy5DYWxsYmFja1Rlc3RSdW5uZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdFbWl0dGluZ1Rlc3RSdW5uZXInLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdHlwZXMuRW1pdHRpbmdUZXN0UnVubmVyO1xuICB9XG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxuZnVuY3Rpb24gX2NoYWxrKCkge1xuICBjb25zdCBkYXRhID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKCdjaGFsaycpKTtcblxuICBfY2hhbGsgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIF9lbWl0dGVyeSgpIHtcbiAgY29uc3QgZGF0YSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZSgnZW1pdHRlcnknKSk7XG5cbiAgX2VtaXR0ZXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkYXRhO1xuICB9O1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBfdGhyb2F0KCkge1xuICBjb25zdCBkYXRhID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKCd0aHJvYXQnKSk7XG5cbiAgX3Rocm9hdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gX2plc3RVdGlsKCkge1xuICBjb25zdCBkYXRhID0gcmVxdWlyZSgnamVzdC11dGlsJyk7XG5cbiAgX2plc3RVdGlsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkYXRhO1xuICB9O1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBfamVzdFdvcmtlcigpIHtcbiAgY29uc3QgZGF0YSA9IHJlcXVpcmUoJ2plc3Qtd29ya2VyJyk7XG5cbiAgX2plc3RXb3JrZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbnZhciBfcnVuVGVzdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZSgnLi9ydW5UZXN0JykpO1xuXG52YXIgX3R5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge2RlZmF1bHQ6IG9ian07XG59XG5cbmZ1bmN0aW9uIF9jbGFzc1ByaXZhdGVNZXRob2RJbml0U3BlYyhvYmosIHByaXZhdGVTZXQpIHtcbiAgX2NoZWNrUHJpdmF0ZVJlZGVjbGFyYXRpb24ob2JqLCBwcml2YXRlU2V0KTtcbiAgcHJpdmF0ZVNldC5hZGQob2JqKTtcbn1cblxuZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZUZpZWxkSW5pdFNwZWMob2JqLCBwcml2YXRlTWFwLCB2YWx1ZSkge1xuICBfY2hlY2tQcml2YXRlUmVkZWNsYXJhdGlvbihvYmosIHByaXZhdGVNYXApO1xuICBwcml2YXRlTWFwLnNldChvYmosIHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gX2NoZWNrUHJpdmF0ZVJlZGVjbGFyYXRpb24ob2JqLCBwcml2YXRlQ29sbGVjdGlvbikge1xuICBpZiAocHJpdmF0ZUNvbGxlY3Rpb24uaGFzKG9iaikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ0Nhbm5vdCBpbml0aWFsaXplIHRoZSBzYW1lIHByaXZhdGUgZWxlbWVudHMgdHdpY2Ugb24gYW4gb2JqZWN0J1xuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBwcml2YXRlTWFwKSB7XG4gIHZhciBkZXNjcmlwdG9yID0gX2NsYXNzRXh0cmFjdEZpZWxkRGVzY3JpcHRvcihyZWNlaXZlciwgcHJpdmF0ZU1hcCwgJ2dldCcpO1xuICByZXR1cm4gX2NsYXNzQXBwbHlEZXNjcmlwdG9yR2V0KHJlY2VpdmVyLCBkZXNjcmlwdG9yKTtcbn1cblxuZnVuY3Rpb24gX2NsYXNzRXh0cmFjdEZpZWxkRGVzY3JpcHRvcihyZWNlaXZlciwgcHJpdmF0ZU1hcCwgYWN0aW9uKSB7XG4gIGlmICghcHJpdmF0ZU1hcC5oYXMocmVjZWl2ZXIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdhdHRlbXB0ZWQgdG8gJyArIGFjdGlvbiArICcgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2UnXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcHJpdmF0ZU1hcC5nZXQocmVjZWl2ZXIpO1xufVxuXG5mdW5jdGlvbiBfY2xhc3NBcHBseURlc2NyaXB0b3JHZXQocmVjZWl2ZXIsIGRlc2NyaXB0b3IpIHtcbiAgaWYgKGRlc2NyaXB0b3IuZ2V0KSB7XG4gICAgcmV0dXJuIGRlc2NyaXB0b3IuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICB9XG4gIHJldHVybiBkZXNjcmlwdG9yLnZhbHVlO1xufVxuXG5mdW5jdGlvbiBfY2xhc3NQcml2YXRlTWV0aG9kR2V0KHJlY2VpdmVyLCBwcml2YXRlU2V0LCBmbikge1xuICBpZiAoIXByaXZhdGVTZXQuaGFzKHJlY2VpdmVyKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F0dGVtcHRlZCB0byBnZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2UnKTtcbiAgfVxuICByZXR1cm4gZm47XG59XG5cbnZhciBfZXZlbnRFbWl0dGVyID0gLyojX19QVVJFX18qLyBuZXcgV2Vha01hcCgpO1xuXG52YXIgX2NyZWF0ZUluQmFuZFRlc3RSdW4gPSAvKiNfX1BVUkVfXyovIG5ldyBXZWFrU2V0KCk7XG5cbnZhciBfY3JlYXRlUGFyYWxsZWxUZXN0UnVuID0gLyojX19QVVJFX18qLyBuZXcgV2Vha1NldCgpO1xuXG5jbGFzcyBUZXN0UnVubmVyIGV4dGVuZHMgX3R5cGVzLkVtaXR0aW5nVGVzdFJ1bm5lciB7XG4gIGNvbnN0cnVjdG9yKC4uLl9hcmdzKSB7XG4gICAgc3VwZXIoLi4uX2FyZ3MpO1xuXG4gICAgX2NsYXNzUHJpdmF0ZU1ldGhvZEluaXRTcGVjKHRoaXMsIF9jcmVhdGVQYXJhbGxlbFRlc3RSdW4pO1xuXG4gICAgX2NsYXNzUHJpdmF0ZU1ldGhvZEluaXRTcGVjKHRoaXMsIF9jcmVhdGVJbkJhbmRUZXN0UnVuKTtcblxuICAgIF9jbGFzc1ByaXZhdGVGaWVsZEluaXRTcGVjKHRoaXMsIF9ldmVudEVtaXR0ZXIsIHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG5ldyAoX2VtaXR0ZXJ5KCkuZGVmYXVsdCkoKVxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgcnVuVGVzdHModGVzdHMsIHdhdGNoZXIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXdhaXQgKG9wdGlvbnMuc2VyaWFsXG4gICAgICA/IF9jbGFzc1ByaXZhdGVNZXRob2RHZXQoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBfY3JlYXRlSW5CYW5kVGVzdFJ1bixcbiAgICAgICAgICBfY3JlYXRlSW5CYW5kVGVzdFJ1bjJcbiAgICAgICAgKS5jYWxsKHRoaXMsIHRlc3RzLCB3YXRjaGVyKVxuICAgICAgOiBfY2xhc3NQcml2YXRlTWV0aG9kR2V0KFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgX2NyZWF0ZVBhcmFsbGVsVGVzdFJ1bixcbiAgICAgICAgICBfY3JlYXRlUGFyYWxsZWxUZXN0UnVuMlxuICAgICAgICApLmNhbGwodGhpcywgdGVzdHMsIHdhdGNoZXIpKTtcbiAgfVxuXG4gIG9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICByZXR1cm4gX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9ldmVudEVtaXR0ZXIpLm9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICB9XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFRlc3RSdW5uZXI7XG5cbmFzeW5jIGZ1bmN0aW9uIF9jcmVhdGVJbkJhbmRUZXN0UnVuMih0ZXN0cywgd2F0Y2hlcikge1xuICBwcm9jZXNzLmVudi5KRVNUX1dPUktFUl9JRCA9ICcxJztcbiAgY29uc3QgbXV0ZXggPSAoMCwgX3Rocm9hdCgpLmRlZmF1bHQpKDEpO1xuICByZXR1cm4gdGVzdHMucmVkdWNlKFxuICAgIChwcm9taXNlLCB0ZXN0KSA9PlxuICAgICAgbXV0ZXgoKCkgPT5cbiAgICAgICAgcHJvbWlzZVxuICAgICAgICAgIC50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICh3YXRjaGVyLmlzSW50ZXJydXB0ZWQoKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgQ2FuY2VsUnVuKCk7XG4gICAgICAgICAgICB9IC8vIGBkZWVwQ3ljbGljQ29weWAgdXNlZCBoZXJlIHRvIGF2b2lkIG1lbS1sZWFrXG5cbiAgICAgICAgICAgIGNvbnN0IHNlbmRNZXNzYWdlVG9KZXN0ID0gKGV2ZW50TmFtZSwgYXJncykgPT5cbiAgICAgICAgICAgICAgX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9ldmVudEVtaXR0ZXIpLmVtaXQoXG4gICAgICAgICAgICAgICAgZXZlbnROYW1lLFxuICAgICAgICAgICAgICAgICgwLCBfamVzdFV0aWwoKS5kZWVwQ3ljbGljQ29weSkoYXJncywge1xuICAgICAgICAgICAgICAgICAga2VlcFByb3RvdHlwZTogZmFsc2VcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBhd2FpdCBfY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX2V2ZW50RW1pdHRlcikuZW1pdChcbiAgICAgICAgICAgICAgJ3Rlc3QtZmlsZS1zdGFydCcsXG4gICAgICAgICAgICAgIFt0ZXN0XVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX3J1blRlc3QuZGVmYXVsdCkoXG4gICAgICAgICAgICAgIHRlc3QucGF0aCxcbiAgICAgICAgICAgICAgdGhpcy5fZ2xvYmFsQ29uZmlnLFxuICAgICAgICAgICAgICB0ZXN0LmNvbnRleHQuY29uZmlnLFxuICAgICAgICAgICAgICB0ZXN0LmNvbnRleHQucmVzb2x2ZXIsXG4gICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQsXG4gICAgICAgICAgICAgIHNlbmRNZXNzYWdlVG9KZXN0XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnRoZW4oXG4gICAgICAgICAgICByZXN1bHQgPT5cbiAgICAgICAgICAgICAgX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9ldmVudEVtaXR0ZXIpLmVtaXQoXG4gICAgICAgICAgICAgICAgJ3Rlc3QtZmlsZS1zdWNjZXNzJyxcbiAgICAgICAgICAgICAgICBbdGVzdCwgcmVzdWx0XVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgZXJyb3IgPT5cbiAgICAgICAgICAgICAgX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9ldmVudEVtaXR0ZXIpLmVtaXQoXG4gICAgICAgICAgICAgICAgJ3Rlc3QtZmlsZS1mYWlsdXJlJyxcbiAgICAgICAgICAgICAgICBbdGVzdCwgZXJyb3JdXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICApLFxuICAgIFByb21pc2UucmVzb2x2ZSgpXG4gICk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIF9jcmVhdGVQYXJhbGxlbFRlc3RSdW4yKHRlc3RzLCB3YXRjaGVyKSB7XG4gIGNvbnN0IHJlc29sdmVycyA9IG5ldyBNYXAoKTtcblxuICBmb3IgKGNvbnN0IHRlc3Qgb2YgdGVzdHMpIHtcbiAgICBpZiAoIXJlc29sdmVycy5oYXModGVzdC5jb250ZXh0LmNvbmZpZy5pZCkpIHtcbiAgICAgIHJlc29sdmVycy5zZXQodGVzdC5jb250ZXh0LmNvbmZpZy5pZCwge1xuICAgICAgICBjb25maWc6IHRlc3QuY29udGV4dC5jb25maWcsXG4gICAgICAgIHNlcmlhbGl6YWJsZU1vZHVsZU1hcDogdGVzdC5jb250ZXh0Lm1vZHVsZU1hcC50b0pTT04oKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgd29ya2VyID0gbmV3IChfamVzdFdvcmtlcigpLldvcmtlcikocmVxdWlyZS5yZXNvbHZlKCcuL3Rlc3RXb3JrZXInKSwge1xuICAgIGV4cG9zZWRNZXRob2RzOiBbJ3dvcmtlciddLFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IG9wdGlvbiBkb2VzIG5vdCBleGlzdCBvbiB0aGUgbm9kZSAxMiB0eXBlc1xuICAgIGZvcmtPcHRpb25zOiB7XG4gICAgICBzZXJpYWxpemF0aW9uOiAnanNvbicsXG4gICAgICBzdGRpbzogJ3BpcGUnXG4gICAgfSxcbiAgICBtYXhSZXRyaWVzOiAzLFxuICAgIG51bVdvcmtlcnM6IHRoaXMuX2dsb2JhbENvbmZpZy5tYXhXb3JrZXJzLFxuICAgIHNldHVwQXJnczogW1xuICAgICAge1xuICAgICAgICBzZXJpYWxpemFibGVSZXNvbHZlcnM6IEFycmF5LmZyb20ocmVzb2x2ZXJzLnZhbHVlcygpKVxuICAgICAgfVxuICAgIF1cbiAgfSk7XG4gIGlmICh3b3JrZXIuZ2V0U3Rkb3V0KCkpIHdvcmtlci5nZXRTdGRvdXQoKS5waXBlKHByb2Nlc3Muc3Rkb3V0KTtcbiAgaWYgKHdvcmtlci5nZXRTdGRlcnIoKSkgd29ya2VyLmdldFN0ZGVycigpLnBpcGUocHJvY2Vzcy5zdGRlcnIpO1xuICBjb25zdCBtdXRleCA9ICgwLCBfdGhyb2F0KCkuZGVmYXVsdCkodGhpcy5fZ2xvYmFsQ29uZmlnLm1heFdvcmtlcnMpOyAvLyBTZW5kIHRlc3Qgc3VpdGVzIHRvIHdvcmtlcnMgY29udGludW91c2x5IGluc3RlYWQgb2YgYWxsIGF0IG9uY2UgdG8gdHJhY2tcbiAgLy8gdGhlIHN0YXJ0IHRpbWUgb2YgaW5kaXZpZHVhbCB0ZXN0cy5cblxuICBjb25zdCBydW5UZXN0SW5Xb3JrZXIgPSB0ZXN0ID0+XG4gICAgbXV0ZXgoYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKHdhdGNoZXIuaXNJbnRlcnJ1cHRlZCgpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgpO1xuICAgICAgfVxuXG4gICAgICBhd2FpdCBfY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX2V2ZW50RW1pdHRlcikuZW1pdCgndGVzdC1maWxlLXN0YXJ0JywgW1xuICAgICAgICB0ZXN0XG4gICAgICBdKTtcbiAgICAgIGNvbnN0IHByb21pc2UgPSB3b3JrZXIud29ya2VyKHtcbiAgICAgICAgY29uZmlnOiB0ZXN0LmNvbnRleHQuY29uZmlnLFxuICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgLi4udGhpcy5fY29udGV4dCxcbiAgICAgICAgICBjaGFuZ2VkRmlsZXM6XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmNoYW5nZWRGaWxlcyAmJlxuICAgICAgICAgICAgQXJyYXkuZnJvbSh0aGlzLl9jb250ZXh0LmNoYW5nZWRGaWxlcyksXG4gICAgICAgICAgc291cmNlc1JlbGF0ZWRUb1Rlc3RzSW5DaGFuZ2VkRmlsZXM6XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnNvdXJjZXNSZWxhdGVkVG9UZXN0c0luQ2hhbmdlZEZpbGVzICYmXG4gICAgICAgICAgICBBcnJheS5mcm9tKHRoaXMuX2NvbnRleHQuc291cmNlc1JlbGF0ZWRUb1Rlc3RzSW5DaGFuZ2VkRmlsZXMpXG4gICAgICAgIH0sXG4gICAgICAgIGdsb2JhbENvbmZpZzogdGhpcy5fZ2xvYmFsQ29uZmlnLFxuICAgICAgICBwYXRoOiB0ZXN0LnBhdGhcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocHJvbWlzZS5VTlNUQUJMRV9vbkN1c3RvbU1lc3NhZ2UpIHtcbiAgICAgICAgLy8gVE9ETzogR2V0IGFwcHJvcHJpYXRlIHR5cGUgZm9yIGBvbkN1c3RvbU1lc3NhZ2VgXG4gICAgICAgIHByb21pc2UuVU5TVEFCTEVfb25DdXN0b21NZXNzYWdlKChbZXZlbnQsIHBheWxvYWRdKSA9PlxuICAgICAgICAgIF9jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfZXZlbnRFbWl0dGVyKS5lbWl0KGV2ZW50LCBwYXlsb2FkKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9KTtcblxuICBjb25zdCBvbkludGVycnVwdCA9IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICB3YXRjaGVyLm9uKCdjaGFuZ2UnLCBzdGF0ZSA9PiB7XG4gICAgICBpZiAoc3RhdGUuaW50ZXJydXB0ZWQpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBDYW5jZWxSdW4oKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICBjb25zdCBydW5BbGxUZXN0cyA9IFByb21pc2UuYWxsKFxuICAgIHRlc3RzLm1hcCh0ZXN0ID0+XG4gICAgICBydW5UZXN0SW5Xb3JrZXIodGVzdCkudGhlbihcbiAgICAgICAgcmVzdWx0ID0+XG4gICAgICAgICAgX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9ldmVudEVtaXR0ZXIpLmVtaXQoJ3Rlc3QtZmlsZS1zdWNjZXNzJywgW1xuICAgICAgICAgICAgdGVzdCxcbiAgICAgICAgICAgIHJlc3VsdFxuICAgICAgICAgIF0pLFxuICAgICAgICBlcnJvciA9PlxuICAgICAgICAgIF9jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfZXZlbnRFbWl0dGVyKS5lbWl0KCd0ZXN0LWZpbGUtZmFpbHVyZScsIFtcbiAgICAgICAgICAgIHRlc3QsXG4gICAgICAgICAgICBlcnJvclxuICAgICAgICAgIF0pXG4gICAgICApXG4gICAgKVxuICApO1xuXG4gIGNvbnN0IGNsZWFudXAgPSBhc3luYyAoKSA9PiB7XG4gICAgY29uc3Qge2ZvcmNlRXhpdGVkfSA9IGF3YWl0IHdvcmtlci5lbmQoKTtcblxuICAgIGlmIChmb3JjZUV4aXRlZCkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgX2NoYWxrKCkuZGVmYXVsdC55ZWxsb3coXG4gICAgICAgICAgJ0Egd29ya2VyIHByb2Nlc3MgaGFzIGZhaWxlZCB0byBleGl0IGdyYWNlZnVsbHkgYW5kIGhhcyBiZWVuIGZvcmNlIGV4aXRlZC4gJyArXG4gICAgICAgICAgICAnVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IHRlc3RzIGxlYWtpbmcgZHVlIHRvIGltcHJvcGVyIHRlYXJkb3duLiAnICtcbiAgICAgICAgICAgICdUcnkgcnVubmluZyB3aXRoIC0tZGV0ZWN0T3BlbkhhbmRsZXMgdG8gZmluZCBsZWFrcy4gJyArXG4gICAgICAgICAgICAnQWN0aXZlIHRpbWVycyBjYW4gYWxzbyBjYXVzZSB0aGlzLCBlbnN1cmUgdGhhdCAudW5yZWYoKSB3YXMgY2FsbGVkIG9uIHRoZW0uJ1xuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gUHJvbWlzZS5yYWNlKFtydW5BbGxUZXN0cywgb25JbnRlcnJ1cHRdKS50aGVuKGNsZWFudXAsIGNsZWFudXApO1xufVxuXG5jbGFzcyBDYW5jZWxSdW4gZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSAnQ2FuY2VsUnVuJztcbiAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBQSxNQUFNLENBQUNDLGNBQVAsQ0FBc0JDLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0VBQzNDQyxLQUFLLEVBQUU7QUFEb0MsQ0FBN0M7QUFHQUgsTUFBTSxDQUFDQyxjQUFQLENBQXNCQyxPQUF0QixFQUErQixvQkFBL0IsRUFBcUQ7RUFDbkRFLFVBQVUsRUFBRSxJQUR1QztFQUVuREMsR0FBRyxFQUFFLGVBQVk7SUFDZixPQUFPQyxNQUFNLENBQUND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